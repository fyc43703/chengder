<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>å…¨èƒ½éŸ³è¨Šç·¨è¼¯å™¨</title>
  <style>
    :root{
      --bg:#ECECEC;
      --panel-bg:rgba(255,255,255,.9);
      --stroke:rgba(0,0,0,.08);
      --shadow:0 8px 30px rgba(0,0,0,.08);
      --blue:#0A84FF;
      --peach:#FF8C66;
      --red:#FF605C; --yellow:#FFBD44; --green:#00CA4E;
      --text:#1c1c1e; --muted:#6e6e73;
      --card-radius:20px;
      --seg-active-bg: white;
      --seg-active-text: var(--blue);
      --theme-btn-bg: rgba(0,0,0,.06);
      --theme-btn-bg-hover: rgba(0,0,0,.1);
    }
    html.dark-theme {
      --bg: #1c1c1e;
      --panel-bg: rgba(44, 44, 46, 0.85);
      --stroke: rgba(255, 255, 255, 0.1);
      --shadow: 0 8px 30px rgba(0,0,0,0.2);
      --text: #f2f2f7;
      --muted: #8e8e93;
      --seg-active-bg: var(--blue);
      --seg-active-text: white;
      --theme-btn-bg: rgba(255,255,255,.1);
      --theme-btn-bg-hover: rgba(255,255,255,.15);
      --btn-ghost-bg: rgba(255,255,255,.08);
      --btn-ghost-bg-hover: rgba(255,255,255,.12);
    }
    html,body{height:100%;}
    body{
      margin:0; background:var(--bg); padding: 24px;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Helvetica, Arial, "PingFang TC", "Noto Sans TC", "Microsoft JhengHei", sans-serif;
      color:var(--text);
      -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
      transition: background-color .3s ease, color .3s ease;
    }
    .frame{max-width:1200px; margin:0 auto; position: relative;}
    .frame > .dots { padding-bottom: 6px; }
    .titlebar{display:flex; align-items:center; justify-content:center; margin-bottom: 0.5rem;}
    .dots{display:flex; gap:8px; align-items:center}
    .dot{width:12px; height:12px; border-radius:50%; box-shadow: inset 0 0 0 1px rgba(0,0,0,.08);}
    .dot.red{background:var(--red);} .dot.yellow{background:var(--yellow);} .dot.green{background:var(--green);}
    .titles{text-align:center; flex-grow:1;}
    .titles h1{margin:0; font-size:26px; font-weight:700;}
    .titles h2{margin:2px 0 0; font-size:14px; font-weight:400; color:var(--muted);}
    .author{font-size:13px; color:var(--muted); white-space:nowrap; margin-top: 0.2rem;}
    .glass{background:var(--panel-bg); border:1px solid var(--stroke); border-radius:var(--card-radius); backdrop-filter: saturate(160%) blur(22px); -webkit-backdrop-filter:sate(160%) blur(22px); box-shadow:var(--shadow); transition: background-color .3s ease, border-color .3s ease;}
    .layout{display:grid; grid-template-columns: 360px 1fr; gap:18px; align-items: start;}
    .sidebar{display:flex; flex-direction:column; gap:12px;}
    .panel{padding:18px;}
    .panel h3{margin:0 0 12px; font-size:16px; font-weight:700; color:var(--muted); text-transform:uppercase; letter-spacing:.8px;}
    .btn{appearance:none; border:none; border-radius:14px; padding:10px 14px; cursor:pointer; font-weight:600; box-shadow:0 1px 0 rgba(0,0,0,.04) inset; transition:.15s ease;}
    .btn.primary{background:var(--blue); color:white;} .btn.primary:hover{filter:brightness(1.05);}
    .btn.ghost{background:rgba(0,0,0,.04);} .btn.ghost:hover{background:rgba(0,0,0,.07);}
    html.dark-theme .btn.ghost { background-color: var(--btn-ghost-bg); }
    html.dark-theme .btn.ghost:hover { background-color: var(--btn-ghost-bg-hover); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    #export.btn.primary { background: var(--peach); }
    #export.btn.primary:hover { filter: brightness(1.08); }
    .toolbar{display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px; justify-content: center;}
    .stack{display:flex; flex-direction:column; gap:12px}
    .slider{display:grid; grid-template-columns:110px 1fr 64px; align-items:center; gap:10px}
    .slider input[type="range"]{width:100%}
    .value{font-variant-numeric: tabular-nums; color:var(--muted);}
    .input-group {display: flex; align-items: center; gap: 8px; margin-top: 8px;}
    .input-group label { flex-shrink: 0; }
    .input-group input[type="number"], .input-group input[type="text"] { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--stroke); background: rgba(255,255,255,.5); font-family: monospace;}
    .filedrop{border:2px dashed rgba(0,0,0,.12); border-radius:16px; padding:12px 16px; text-align:center; display: flex; flex-direction: column; align-items: center; gap: 12px;}
    .grid{display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px;}
    .seg{display:flex; gap:6px; background:rgba(0,0,0,.06); padding:6px; border-radius:12px}
    .seg .format-btn, .seg button { background: transparent; border: none; padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; color: var(--muted); font-size: 16px; line-height: 1; transition: .15s ease; }
    .seg .format-btn.active, .seg button.active { background: var(--seg-active-bg); color: var(--seg-active-text); box-shadow: 0 1px 3px rgba(0,0,0,.05); }
    canvas{width:100%; display:block; border-radius:14px; background:rgba(255,255,255,.65); border:1px solid var(--stroke)}
    .badge{font-size:12px; color:var(--muted)}
    .scope-container{ margin-top: 12px; grid-column: 1 / -1; }
    .analyzer-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .analyzer-item { display: flex; flex-direction: column; gap: 6px; }
    .analyzer-item .badge { text-align: center; }
    #waveformContainer { position: relative; margin-bottom: 12px; }
    .playhead { position: absolute; top: 0; left: 0; width: 4px; height: 100%; background-color: var(--red); pointer-events: none; transform: translateX(-2px); }
    .selection-rect { position: absolute; top: 0; background-color: rgba(10, 132, 255, 0.3); border: 2px solid var(--blue); pointer-events: none; height: 100%; box-sizing: border-box; }
    .time-container { margin-bottom: 12px; position: relative; padding-top: 10px; }
    #time-ruler { width: 100%; height: 20px; background: rgba(0,0,0,0.05); border-radius: 10px; cursor: pointer; position: relative; }
    #time-indicator { position: absolute; top: 0; left: 0; width: 4px; height: 100%; background: var(--blue); transform: translateX(-2px); }
    #time-indicator::before { content: ''; position: absolute; top: -10px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 10px solid var(--blue); }
    #time-hover-info { position: absolute; bottom: 100%; left: 0; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; display: none; }
    #timeDisplay { font-size: 20px; font-weight: 500; text-align: center; color: var(--muted); letter-spacing: 1px; margin-top: 8px; font-variant-numeric: tabular-nums;}
    .player-controls { display: flex; flex-direction: column; align-items: center; gap: 8px; margin: 12px 0 20px; padding: 10px 12px; background: rgba(0,0,0,0.04); border-radius: 16px;}
    .player-controls .slider-group { display: grid; grid-template-columns: repeat(3, 1fr); gap:12px; width:100%; }
    .player-controls .slider { grid-template-columns: 70px 1fr 50px; gap: 8px; font-size: 13px; }
    .player-controls .transport-group { display: flex; align-items: center; gap: 10px; }
    .loop-controls { display: flex; flex-wrap: wrap; gap: 4px 10px; align-items: center; width: 100%; justify-content: center; }
    .loop-controls .input-group { margin-top: 0; }
    .loop-controls label, .loop-controls .input-group { font-size: 13px; }
    .loop-controls .input-group input { width: 75px; text-align: center; }
    .zoom-controls { display: flex; gap: 10px; justify-content: center; margin-top: 10px; grid-column: 1 / -1; }
    .zoom-controls .btn { padding: 6px 12px; font-size: 13px; border-radius: 10px; }
    #scope, #oscilloscopeCanvas, #vectorscopeCanvas, #peakMeterCanvas { height: 100px; }
    #loadingIndicator { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.7); backdrop-filter: blur(5px); display: flex; justify-content: center; align-items: center; z-index: 9999; flex-direction: column; gap: 10px; color: var(--muted); font-weight: 600; }
    html.dark-theme #loadingIndicator { background: rgba(0,0,0,0.6); }
    .spinner { width: 50px; height: 50px; border: 5px solid rgba(0,0,0,0.1); border-top-color: var(--blue); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    #exportStatus { display: flex; align-items: center; justify-content: center; gap: 8px; }
    #exportStatus .spinner { width: 18px; height: 18px; border: 2px solid rgba(10, 132, 255, 0.2); border-top-color: var(--blue); }
    .file-list-container { max-height: 140px; overflow-y: auto; border: 1px solid var(--stroke); border-radius: 8px; padding: 8px 12px; margin-top: 12px; background: rgba(0,0,0,.04); }
    #fileList { list-style-type: decimal; list-style-position: inside; padding-left: 0; margin: 0; display: flex; flex-direction: column; gap: 2px; }
    #fileList li { font-size: 13px; color: var(--text); padding: 4px 8px; cursor: pointer; border-radius: 6px; transition: background-color 0.15s ease; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    #fileList li:hover { background-color: rgba(0,0,0,.07); }
    html.dark-theme #fileList li:hover { background-color: rgba(255,255,255,.07); }
    #fileList li.active { background-color: var(--blue); color: white; font-weight: 600; }
    #fileList:empty::after { content: "å°šæœªåŒ¯å…¥ä»»ä½•æª”æ¡ˆ"; color: var(--muted); font-style: italic; font-size: 13px; }
    .grid .slider { grid-template-columns: 95px 1fr 60px; gap: 8px; }
    .grid .slider label { font-size: 13px; }
    .theme-switcher { position: absolute; top: -14px; right: 0; }
    .theme-switcher button { background: var(--theme-btn-bg); border: none; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; color: var(--text); transition: background-color .2s ease; }
    .theme-switcher button:hover { background: var(--theme-btn-bg-hover); }
    .theme-switcher svg { width: 22px; height: 22px; }
    #theme-icon-sun { display: none; }
    html.dark-theme #theme-icon-moon { display: none; }
    html.dark-theme #theme-icon-sun { display: block; }
    .edit-toolbar { display: flex; flex-direction: column; gap: 10px; align-items: flex-start; }
    .edit-toolbar > .btn, .effect-group > .btn { display: inline-flex; align-items: center; gap: 8px; width: 100%; justify-content: flex-start; text-align: left; }
    .edit-toolbar > .btn svg { width: 18px; height: 18px; flex-shrink: 0; }
    .effect-group { border-top: 1px solid var(--stroke); padding-top: 10px; margin-top: 2px; width: 100%; display: flex; flex-direction: column; gap: 8px; }
    .effect-group h4 { margin: 0 0 4px 0; font-size: 14px; font-weight: 600; color: var(--text); display: flex; align-items: center; gap: 8px; }
    .effect-group h4.blue-title { color: var(--blue); }
    .effect-group h4 svg { width: 18px; height: 18px; flex-shrink: 0; }
    .effect-group .slider { grid-template-columns: 80px 1fr 64px; font-size: 13px; }
    .effect-group .btn { margin-top: 4px; background-color: rgba(0,0,0,0.06); }
    html.dark-theme .effect-group .btn { background-color: var(--btn-ghost-bg); }
    .effect-group .btn:hover { background-color: rgba(0,0,0,0.09); }
    html.dark-theme .effect-group .btn:hover { background-color: var(--btn-ghost-bg-hover); }
    .btn.center-text { justify-content: center; text-align: center; }
    
    /* ===== START OF RWD ADJUSTMENTS ===== */
    
    /* Tablet View (1024px and below) */
    @media (max-width: 1024px) {
        .layout {
            grid-template-columns: 1fr; /* Stack sidebar and main content */
        }
    }
    
    /* Mobile View (768px and below) */
    @media (max-width: 768px) {
        body { padding: 16px; }
        .layout { gap: 12px; }
        .titles h1 { font-size: 22px; }
        .titles h2 { font-size: 13px; }
        .analyzer-grid { grid-template-columns: 1fr 1fr; }
        
        /* --- MOBILE SLIDER LAYOUT REVOLUTION --- */
        /* Universal rule for all sliders on mobile */
        .slider {
            grid-template-columns: 1fr auto; /* Slider takes all space, value aligns to the right */
            grid-template-rows: auto auto;    /* Two rows: 1 for label, 1 for slider+value */
            gap: 4px 10px;                   /* Adjust gap for compact view */
            align-items: center;
        }
        .slider label {
            grid-column: 1 / -1;             /* Label spans full width, effectively placing it on top */
            margin-bottom: 2px;
            font-size: 13px;
            font-weight: 500;
        }
        .slider input[type="range"] {
            grid-row: 2;                     /* Explicitly put slider on the second row */
            grid-column: 1 / 2;
        }
        .slider .value {
            grid-row: 2;                     /* Value also on the second row */
            grid-column: 2 / 3;
            justify-self: end;
        }
        
        .player-controls .slider-group, .grid {
            grid-template-columns: 1fr; /* Stack sliders vertically */
        }
    }

    /* Extra small screens (e.g., small phones, 480px and below) */
    @media (max-width: 480px) {
        body { padding: 10px; }
        .panel { padding: 12px; }
        .analyzer-grid { grid-template-columns: 1fr; }
        .loop-controls { flex-direction: column; gap: 8px; }
        #exportPanel .toolbar button { width: 100%; }
        .theme-switcher { top: -8px; }
    }
    /* ===== END OF RWD ADJUSTMENTS ===== */
  </style>
</head>
<body>
  <div class="frame">
    <div class="dots">
      <span class="dot red"></span><span class="dot yellow"></span><span class="dot green"></span>
    </div>
    <div class="titlebar">
      <div class="titles">
        <h1>å…¨èƒ½éŸ³è¨Šç·¨è¼¯å™¨</h1>
        <h2>æä¾›éŸ³æ¨‚æ’­æ”¾ã€MP3 è½‰æª”ã€æª”æ¡ˆåˆ†å‰²ã€éŸ³è¨Šå‰ªè¼¯ã€éŸ³é‡æ¨™æº–åŒ–ã€å„é …åˆ†æå„€æ³¢å½¢åŠé »è­œ</h2>
        <div class="author">è£½ä½œè€…ï¼šé™³æ”¿å¾·</div>
      </div>
    </div>
    
    <div class="theme-switcher">
      <button id="theme-toggle" title="åˆ‡æ›æ˜æš—æ¨¡å¼">
        <svg id="theme-icon-moon" fill="currentColor" viewBox="0 0 24 24"><path d="M12 3a9 9 0 1 0 9 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 0 1-4.4-4.45A8.995 8.995 0 0 0 12 3z"></path></svg>
        <svg id="theme-icon-sun" fill="currentColor" viewBox="0 0 24 24"><path d="M12 9a3 3 0 1 0 3 3 3 3 0 0 0-3-3zm0-4.5a1.5 1.5 0 0 1 1.5 1.5v1.5a1.5 1.5 0 0 1-3 0V6a1.5 1.5 0 0 1 1.5-1.5zm0 15a1.5 1.5 0 0 1-1.5-1.5v-1.5a1.5 1.5 0 0 1 3 0V18a1.5 1.5 0 0 1-1.5 1.5zM4.5 12a1.5 1.5 0 0 1 1.5-1.5h1.5a1.5 1.5 0 0 1 0 3H6a1.5 1.5 0 0 1-1.5-1.5zm15 0a1.5 1.5 0 0 1-1.5 1.5h-1.5a1.5 1.5 0 0 1 0-3H18a1.5 1.5 0 0 1 1.5 1.5zM7.05 7.05a1.5 1.5 0 0 1 2.12 0l1.06 1.06a1.5 1.5 0 0 1-2.12 2.12l-1.06-1.06a1.5 1.5 0 0 1 0-2.12zm9.9 9.9a1.5 1.5 0 0 1 0-2.12l-1.06-1.06a1.5 1.5 0 0 1-2.12 2.12l1.06 1.06a1.5 1.5 0 0 1 2.12 0zm-9.9 0a1.5 1.5 0 0 1 0 2.12l1.06 1.06a1.5 1.5 0 1 1-2.12 2.12l-1.06-1.06a1.5 1.5 0 0 1 2.12 0zm9.9-9.9a1.5 1.5 0 0 1 2.12 0l1.06 1.06a1.5 1.5 0 1 1-2.12 2.12l-1.06-1.06a1.5 1.5 0 0 1 0-2.12z"></path></svg>
      </button>
    </div>

    <div class="layout">
      <!-- Left panels -->
      <div class="sidebar">
        <div class="panel glass stack">
          <h3>åŒ¯å…¥åŠåŒ¯å‡ºéŸ³è¨Š</h3>
          <div class="filedrop" id="drop" title="å°‡éŸ³è¨Šæª”æ¡ˆæ‹–æ›³è‡³æ­¤è™•ä»¥ä¸Šå‚³">
            <label class="btn primary" title="é»æ“Šæ­¤è™•é¸æ“‡ä¸€å€‹æˆ–å¤šå€‹éŸ³è¨Šæª”æ¡ˆ">
              é¸æ“‡æª”æ¡ˆ
              <input id="file" type="file" accept="audio/*,.m4a,.ogg,.aac,.3gp" hidden multiple>
            </label>
            <div class="badge">æ”¯æ´å¸¸è¦‹æ ¼å¼ï¼Œå¦‚WAV, MP3, M4A, OGGç­‰</div>
          </div>
          <div class="file-list-container">
              <label style="font-size: 13px; color: var(--muted); display: block; margin-bottom: 6px;">å·²åŒ¯å…¥æª”æ¡ˆåˆ—è¡¨ï¼š</label>
              <ol id="fileList"></ol>
          </div>
          <div class="toolbar">
             <button id="export" class="btn primary" title="è¨­å®šåŒ¯å‡ºæ ¼å¼ä¸¦å„²å­˜è™•ç†å¾Œçš„éŸ³è¨Š">ğŸ’¾ <span>åŒ¯å‡ºè™•ç†å¾ŒéŸ³è¨Š</span></button>
          </div>
        </div>

        <div class="panel glass stack">
            <h3>ä¿®å¾©èˆ‡ç·¨è¼¯</h3>
            <div class="edit-toolbar">
              <button id="normalizeBtn" class="btn ghost" title="å°‡éŸ³è¨Šçš„æœ€å¤§éŸ³é‡èª¿æ•´è‡³ -1 dBFSï¼Œä½¿æ•´é«”éŸ³é‡ä¸€è‡´">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 15V9H6V15H4Z" fill="#FF605C"></path><path d="M8 17V7H10V17H8Z" fill="#FFBD44"></path><path d="M12 20V4H14V20H12Z" fill="#00CA4E"></path><path d="M16 17V7H18V17H16Z" fill="#FFBD44"></path><path d="M20 15V9H22V15H20Z" fill="#FF605C"></path></svg>
                <span>éŸ³é‡æ¨™æº–åŒ– (-1 dBFS)</span>
              </button>

              <div class="effect-group">
                <h4 class="blue-title"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12H5L7 7L9 17L11 10L13 14L15 9L17 15L19 12H22" stroke="#0A84FF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M4 8L2 10L4 12" stroke="#FF8C66" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M20 8L22 10L20 12" stroke="#FF8C66" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>å‹•æ…‹å£“ç¸®å™¨</h4>
                <div class="slider">
                  <label>é–¾å€¼</label>
                  <input id="compThreshold" type="range" min="-80" max="0" step="1" value="-24" title="å£“ç¸®å™¨é–‹å§‹ä½œç”¨çš„éŸ³é‡æ°´å¹³">
                  <div class="value" id="compThresholdV">-24 dB</div>
                </div>
                <div class="slider">
                  <label>æ¯”ç‡</label>
                  <input id="compRatio" type="range" min="1" max="20" step="0.1" value="4" title="è¶…éé–¾å€¼æ™‚éŸ³é‡è¢«å£“ç¸®çš„ç¨‹åº¦">
                  <div class="value" id="compRatioV">4.0:1</div>
                </div>
                <button id="applyCompressorBtn" class="btn ghost center-text" title="å°‡ç›®å‰çš„å£“ç¸®å™¨è¨­å®šå¥—ç”¨è‡³æ•´å€‹éŸ³è¨Š">å¥—ç”¨å£“ç¸®</button>
              </div>
        
              <div class="effect-group">
                <h4 class="blue-title"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="14" width="4" height="6" rx="1" fill="#FF605C"></rect><rect x="10" y="4" width="4" height="16" rx="1" fill="#FFBD44"></rect><rect x="16" y="10" width="4" height="10" rx="1" fill="#00CA4E"></rect></svg>éŸ³é‡å‡è¡¡ (æœ€å¤§åŒ–)</h4>
                <div class="slider">
                  <label>å¼·åº¦</label>
                  <input id="maximizeAmount" type="range" min="0" max="100" step="1" value="50" title="æå‡æ•´é«”éŸ³é‡ä¸¦é™ä½å‹•æ…‹ç¯„åœçš„å¼·åº¦">
                  <div class="value" id="maximizeAmountV">50 %</div>
                </div>
                <button id="applyMaximizerBtn" class="btn ghost center-text" title="å°‡ç›®å‰çš„éŸ³é‡å‡è¡¡è¨­å®šå¥—ç”¨è‡³æ•´å€‹éŸ³è¨Š">å¥—ç”¨å‡è¡¡</button>
              </div>
              
              <div style="border-top: 1px solid var(--stroke); width:100%; margin: 8px 0;"></div>
        
              <button id="trimBtn" class="btn ghost" title="åƒ…ä¿ç•™åœ¨æ³¢å½¢åœ–ä¸Šé¸å–çš„ç¯„åœï¼Œè£å‰ªæ‰å…¶é¤˜éƒ¨åˆ†">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="7.5" cy="17.5" r="2.5" stroke="#FF605C" stroke-width="2"></circle><circle cx="7.5" cy="6.5" r="2.5" stroke="#0A84FF" stroke-width="2"></circle><line x1="9.5" y1="15.5" x2="18" y2="7" stroke="#6e6e73" stroke-width="2"></line><line x1="9.5" y1="8.5" x2="18" y2="17" stroke="#6e6e73" stroke-width="2"></line></svg>
                <span>è£å‰ª ( åƒ…ä¿ç•™æ‹–æ›³ç¯„åœï¼Œç§»é™¤å…¶é¤˜éŸ³è¨Š )</span>
              </button>
              <button id="deleteBtn" class="btn ghost" title="å¾éŸ³è¨Šä¸­ç§»é™¤åœ¨æ³¢å½¢åœ–ä¸Šé¸å–çš„ç¯„åœ">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 19C6 20.1046 6.89543 21 8 21H16C17.1046 21 18 20.1046 18 19V7H6V19Z" fill="#FF605C"></path><path d="M19 4H15.5L14.5 3H9.5L8.5 4H5V6H19V4Z" fill="#FF8C66"></path></svg>
                <span>åˆªé™¤ ( å¯å¤šæ¬¡åˆªé™¤æ‹–æ›³ç¯„åœï¼Œç§»é™¤é–‹é ­åŠçµå°¾ )</span>
              </button>
            </div>
        </div>
      </div>

      <!-- Right main area -->
      <div class="panel glass" id="mainRightPanel">
        <h3>æ³¢å½¢ç·¨è¼¯èˆ‡EQ</h3>
        <div id="waveformContainer">
            <canvas id="waveformCanvas"></canvas>
            <div id="playhead" class="playhead" style="display: none;"></div>
            <div id="selectionRect" class="selection-rect" style="display: none;"></div>
        </div>
        
        <div class="time-container">
            <div id="time-ruler" title="é»æ“Šæ™‚é–“è»¸ä»¥è·³è½‰æ’­æ”¾ä½ç½®">
                <div id="time-indicator"></div>
                <div id="time-hover-info">00:00.0</div>
            </div>
            <div id="timeDisplay">00:00.0 / 00:00.0</div>
        </div>

        <div class="player-controls">
          <div class="transport-group">
            <div class="seg">
              <button id="prevTrackBtn" title="ä¸Šä¸€é¦–">â®</button>
              <button id="play" title="æ’­æ”¾">â–¶ï¸</button>
              <button id="pause" title="æš«åœ">â¸</button>
              <button id="stop" title="åœæ­¢ä¸¦å›åˆ°é–‹é ­">â¹</button>
              <button id="nextTrackBtn" title="ä¸‹ä¸€é¦–">â­</button>
            </div>
          </div>
           <div class="loop-controls" title="å€æ®µæ’­æ”¾ï¼šé¸å–ç¯„åœ â†’ å‹¾é¸å¾ªç’° â†’ æŒ‰ä¸‹åœæ­¢éµ â†’ å†æŒ‰æ’­æ”¾éµå³å¯å¾ªç’°">
                <div class="input-group">
                    <label>é–‹å§‹:</label>
                    <input type="text" id="loopStart" value="00:00.0" title="å¾ªç’°æ’­æ”¾çš„é–‹å§‹æ™‚é–“ (åˆ†:ç§’.æ¯«ç§’)ï¼Œå¯æ‹–æ›³æ³¢å½¢é¸å–">
                </div>
                <div class="input-group">
                    <label>çµæŸ:</label>
                    <input type="text" id="loopEnd" value="00:00.0" title="å¾ªç’°æ’­æ”¾çš„çµæŸæ™‚é–“ (åˆ†:ç§’.æ¯«ç§’)ï¼Œå¯æ‹–æ›³æ³¢å½¢é¸å–">
                </div>
                <div class="input-group">
                    <input type="checkbox" id="loopToggle" style="width: auto;" title="å•Ÿç”¨æˆ–åœç”¨å¾ªç’°æ’­æ”¾é¸å–ç¯„åœ">
                    <label for="loopToggle">å¾ªç’°æ’­æ”¾é¸å–ç¯„åœ</label>
                </div>
            </div>
          <div class="slider-group">
            <div class="slider">
              <label>éŸ³é‡</label>
              <input id="gain" type="range" min="0" max="2" step="0.01" value="1" title="èª¿æ•´æ’­æ”¾éŸ³é‡"/>
              <div class="value" id="gainV">1.00</div>
            </div>
            <div class="slider">
              <label>å¹³è¡¡</label>
              <input id="pan" type="range" min="-1" max="1" step="0.01" value="0" title="èª¿æ•´å·¦å³è²é“å¹³è¡¡ (-1ç‚ºå·¦, 1ç‚ºå³)"/>
              <div class="value" id="panV">0.00</div>
            </div>
            <div class="slider">
              <label>é€Ÿåº¦</label>
              <input id="rate" type="range" min="0.5" max="2" step="0.01" value="1" title="èª¿æ•´æ’­æ”¾é€Ÿåº¦">
              <div class="value" id="rateV">1.00x</div>
            </div>
             <div class="zoom-controls">
                <button id="zoomInBtn" class="btn ghost" title="æ”¾å¤§æ³¢å½¢åœ–é¡¯ç¤º (Shift + æ»‘é¼ æ‹–æ›³å¯å¹³ç§»)">æ”¾å¤§</button>
                <button id="zoomOutBtn" class="btn ghost" title="ç¸®å°æ³¢å½¢åœ–é¡¯ç¤º">ç¸®å°</button>
                <button id="zoomAllBtn" class="btn ghost" title="é‡è¨­ç¸®æ”¾ï¼Œé¡¯ç¤ºå®Œæ•´çš„éŸ³è¨Šæ³¢å½¢">é¡¯ç¤ºå…¨éƒ¨</button>
            </div>
          </div>
        </div>

        <div class="grid">
          <div class="slider"><label>ä½é »åˆ‡é™¤</label><input id="hp" type="range" min="20" max="500" step="1" value="80" title="æ¿¾é™¤æŒ‡å®šé »ç‡ä»¥ä¸‹çš„ä½é »å™ªéŸ³"><div class="value" id="hpV">80 Hz</div></div>
          <div class="slider"><label>é«˜é »åˆ‡é™¤</label><input id="lp" type="range" min="2000" max="20000" step="10" value="12000" title="æ¿¾é™¤æŒ‡å®šé »ç‡ä»¥ä¸Šçš„é«˜é »å™ªéŸ³"><div class="value" id="lpV">12 kHz</div></div>
          <div class="slider"><label>å³°å€¼é »ç‡</label><input id="peakF" type="range" min="200" max="8000" step="1" value="2500" title="è¨­å®šè¦å¢å¼·æˆ–è¡°æ¸›çš„ä¸­å¿ƒé »ç‡"><div class="value" id="pfV">2500 Hz</div></div>
          <div class="slider"><label>å³°å€¼å¢ç›Š</label><input id="peakG" type="range" min="-15" max="15" step="0.1" value="0" title="å¢å¼·æˆ–è¡°æ¸›å³°å€¼é »ç‡çš„éŸ³é‡"><div class="value" id="pgV">0 dB</div></div>
          <div class="slider"><label>é »å¯¬ (Q)</label><input id="peakQ" type="range" min="0.1" max="18" step="0.1" value="2" title="èª¿æ•´å³°å€¼ç­‰åŒ–å™¨å½±éŸ¿çš„é »ç‡ç¯„åœ (Qå€¼è¶Šé«˜å½±éŸ¿è¶Šçª„)"><div class="value" id="pqV">2.0</div></div>
          <div class="slider"><label>å‹•æ…‹EQé–¾å€¼</label><input id="deqThreshold" type="range" min="-100" max="0" step="1" value="-100" title="è¨­å®šå‹•æ…‹ç­‰åŒ–å™¨è§¸ç™¼çš„éŸ³é‡é–¾å€¼"><div class="value" id="deqTV">-inf dB</div></div>
          <div class="scope-container">
              <div class="analyzer-grid">
                  <div class="analyzer-item">
                      <canvas id="scope"></canvas>
                      <div class="badge">åˆ†æå„€ï¼šå³æ™‚é »è­œ</div>
                  </div>
                  <div class="analyzer-item">
                      <canvas id="oscilloscopeCanvas"></canvas>
                      <div class="badge">åˆ†æå„€ï¼šå³æ™‚æ³¢å½¢ (ç¤ºæ³¢å™¨)</div>
                  </div>
                  <div class="analyzer-item">
                      <canvas id="vectorscopeCanvas"></canvas>
                      <div class="badge">åˆ†æå„€ï¼šç«‹é«”è²å‘é‡ç¤ºæ³¢å™¨</div>
                  </div>
                  <div class="analyzer-item">
                      <canvas id="peakMeterCanvas"></canvas>
                      <div class="badge">åˆ†æå„€ï¼šé›™è²é“å³°å€¼é›»å¹³éŒ¶</div>
                  </div>
              </div>
          </div>
        </div>
      </div>

      <!-- EXPORT PANEL (Initially Hidden) -->
      <div class="panel glass stack" id="exportPanel" style="display: none;">
          <h3>åŒ¯å‡ºè¨­å®š</h3>
          
          <div class="slider">
              <label>èª¿æ•´éŸ³é‡</label>
              <input id="exportGain" type="range" min="0" max="2" step="0.01" value="1" title="åœ¨åŒ¯å‡ºå‰å°éŸ³è¨Šåšæœ€å¾Œçš„éŸ³é‡èª¿æ•´">
              <div class="value" id="exportGainV">1.00</div>
          </div>
          
          <div style="margin-top: 12px;">
            <label>åŒ¯å‡ºçš„éŸ³è¨Šæ ¼å¼</label>
            <div class="seg" id="formatSelector" style="margin-top:4px; justify-content: center;">
                <button class="format-btn active" data-format="wav" title="åŒ¯å‡ºç‚ºç„¡æçš„ WAV æ ¼å¼ï¼Œæª”æ¡ˆè¼ƒå¤§">WAV</button>
                <button class="format-btn" data-format="mp3" title="åŒ¯å‡ºç‚ºæœ‰æå£“ç¸®çš„ MP3 æ ¼å¼ï¼Œæª”æ¡ˆè¼ƒå°">MP3</button>
            </div>
             <div class="badge" style="text-align: center; margin-top: 8px;">è¨»ï¼šå› ç€è¦½å™¨æŠ€è¡“é™åˆ¶ï¼Œåƒ…æ”¯æ´åŒ¯å‡ºWAV/MP3æ ¼å¼</div>
          </div>

          <div id="mp3Options" class="stack" style="display: none; margin-top: 12px; gap: 12px;">
              <div class="slider">
                  <label>MP3 ä½å…ƒç‡</label>
                  <input id="mp3Bitrate" type="range" min="64" max="320" step="32" value="192" title="è¨­å®šMP3çš„å£“ç¸®å“è³ªï¼Œä½å…ƒç‡è¶Šé«˜éŸ³è³ªè¶Šå¥½ï¼Œæª”æ¡ˆè¶Šå¤§">
                  <div class="value" id="mp3BitrateV">192 kbps</div>
              </div>
              <div>
                <label>è²é“</label>
                <div class="seg" id="channelSelector" style="margin-top:4px; justify-content: center;">
                    <button class="format-btn active" data-channels="source" title="ä¿æŒèˆ‡ä¾†æºæª”æ¡ˆç›¸åŒçš„è²é“æ•¸">ä¾†æºé è¨­</button>
                    <button class="format-btn" data-channels="mono" title="å°‡ç«‹é«”è²æ··åˆç‚ºå–®è²é“">å–®è²é“</button>
                </div>
              </div>
          </div>
          
          <div style="margin-top: 12px;">
            <label>åˆ†å‰²æª”æ¡ˆï¼ˆ åˆ†å‰² MP3 å£“ç¸®æ ¼å¼è¼ƒè€—æ™‚ï¼Œè«‹è€å¿ƒç­‰å€™ ï¼ ï¼‰</label>
            <div class="input-group">
                <label for="splitCount">å¹³å‡åˆ†å‰²ç‚º</label>
                <input type="number" id="splitCount" min="1" placeholder="ä»½æ•¸" title="å°‡éŸ³è¨Šå¹³å‡åˆ†å‰²æˆæŒ‡å®šæ•¸é‡çš„æª”æ¡ˆå†åŒ¯å‡º">
                <label>ä»½</label>
            </div>
          </div>
          
          <div id="exportStatus" class="badge" style="text-align: center; margin-top: 12px; display: none;">
            <div class="spinner"></div>
            <span id="exportStatusText">éŸ³è¨Šè™•ç†ä¸­ï¼Œè«‹ç¨å€™...</span>
          </div>

          <div class="toolbar" style="margin-top: 24px; display:flex; justify-content:center; gap: 10px;">
              <button id="saveFileBtn" class="btn primary" style="width: 33.33%;" title="é–‹å§‹è™•ç†éŸ³è¨Šä¸¦è§¸ç™¼ç€è¦½å™¨ä¸‹è¼‰">å¦å­˜æ–°æª”</button>
              <button id="cancelExportBtn" class="btn ghost" style="width: 33.33%;" title="å–æ¶ˆåŒ¯å‡ºä¸¦è¿”å›ä¸»ç·¨è¼¯ä»‹é¢">å–æ¶ˆ</button>
          </div>
      </div>
      <a id="download" style="display:none"></a>
    </div>
    
    <div id="loadingIndicator" style="display: none;">
        <div class="spinner"></div>
        <div>è™•ç†ä¸­...</div>
    </div>
  </div>

  <script>
  // ===== Web Audio Setup =====
  const AC = new (window.AudioContext || window.webkitAudioContext)();
  
  const preEffectNode = AC.createGain();
  const gain = AC.createGain(), pan = AC.createStereoPanner(), analyser = AC.createAnalyser();
  analyser.fftSize = 2048;

  const splitter = AC.createChannelSplitter(2);
  const analyserL = AC.createAnalyser(); analyserL.fftSize = 2048;
  const analyserR = AC.createAnalyser(); analyserR.fftSize = 2048;

  const hp = AC.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 80; hp.Q.value = 0.707;
  const peak = AC.createBiquadFilter(); peak.type = 'peaking'; peak.frequency.value = 2500; peak.Q.value = 2;
  const lp = AC.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 12000; lp.Q.value = 0.707;
  const deqCompressor = AC.createDynamicsCompressor(); deqCompressor.attack.value = 0.001; deqCompressor.release.value = 0.1;
  const deqInvert = AC.createGain(); deqInvert.gain.value = -1;
  const deqMakeUp = AC.createGain();

  preEffectNode.connect(hp).connect(lp).connect(pan).connect(gain).connect(analyser).connect(AC.destination);
  gain.connect(splitter);
  splitter.connect(analyserL, 0);
  splitter.connect(analyserR, 1);
  
  const deqChainInput = AC.createGain();
  pan.connect(deqChainInput);
  deqChainInput.connect(peak).connect(deqCompressor).connect(deqInvert).connect(deqMakeUp);
  deqMakeUp.connect(gain);
  
  let audioBuffer = null, sourceNode = null;
  let isPlaying = false, startTime = 0, pausedAt = 0, animationFrameId = null;
  let loopStart = 0, loopEnd = 0, isLooping = false;
  let zoom = 1; let viewOffset = 0;
  let mp3EncoderWorker = null;
  let importedFiles = []; // Array for storing imported File objects
  let currentFileIndex = -1; 

  const $ = (id) => document.getElementById(id);
  const setVal = (id, txt) => $(id).textContent = txt;
  
  const waveformCanvas = $('waveformCanvas'), waveformCtx = waveformCanvas.getContext('2d');
  const playhead = $('playhead'), selectionRect = $('selectionRect');
  let isDragging = false, selectionStart = 0, selectionEnd = 0;

  function updateFileList() {
      const listElement = $('fileList');
      if (!listElement) return;
      listElement.innerHTML = '';
      
      const currentFileName = importedFiles[currentFileIndex]?.name;

      importedFiles.forEach((file, index) => {
          const li = document.createElement('li');
          li.textContent = file.name;
          li.title = file.name;
          
          if (file.name === currentFileName) {
              li.classList.add('active');
          }

          li.onclick = () => {
              if (file.name !== currentFileName) {
                  loadFile(file);
              }
          };
          listElement.appendChild(li);
      });

      const trackButtons = [$('prevTrackBtn'), $('nextTrackBtn')];
      if (importedFiles.length > 1) {
          trackButtons.forEach(btn => btn.disabled = false);
      } else {
          trackButtons.forEach(btn => btn.disabled = true);
      }
  }

  function handleFiles(files) {
      if (!files || files.length === 0) return;
      const wasEmpty = audioBuffer === null;
      let newFilesAdded = false;

      for (const file of files) {
          if (!importedFiles.some(f => f.name === file.name)) {
              importedFiles.push(file);
              newFilesAdded = true;
          }
      }
      
      if (newFilesAdded) {
         updateFileList();
      }

      if (wasEmpty && files.length > 0) {
          loadFile(importedFiles[0]); 
      }
  }

  async function loadFile(file) {
    stop();
    $('loadingIndicator').querySelector('div:last-child').textContent = 'éŸ³è¨Šè¼‰å…¥ä¸­...';
    $('loadingIndicator').style.display = 'flex';
    try {
      const arrayBuffer = await file.arrayBuffer();
      audioBuffer = await AC.decodeAudioData(arrayBuffer);
      currentFileIndex = importedFiles.findIndex(f => f.name === file.name);
      updateFileList();
      const duration = audioBuffer ? audioBuffer.duration : 0;
      $('loopStart').value = formatTime(0);
      $('loopEnd').value = formatTime(duration);
      loopStart = 0;
      loopEnd = duration;
      updateTimeDisplay();
      resetUI();
      drawWaveform();
    } catch (e) {
      console.error("Error decoding audio file:", e);
      audioBuffer = null;
      updateFileList();
    } finally {
        $('loadingIndicator').style.display = 'none';
    }
  }
  
  $('file').onchange = e => handleFiles(e.target.files);
  const drop = $('drop');
  drop.ondragover = e => { e.preventDefault(); drop.style.borderColor = 'var(--blue)'; };
  drop.ondragleave = () => drop.style.borderColor = '';
  drop.ondrop = e => {
      e.preventDefault();
      drop.style.borderColor = '';
      handleFiles(e.dataTransfer.files);
  };

  function play(startOffset = pausedAt) {
    if (isPlaying || !audioBuffer) return;
    if(isLooping && startOffset >= loopEnd) startOffset = loopStart;

    sourceNode = AC.createBufferSource(); sourceNode.buffer = audioBuffer;
    sourceNode.connect(preEffectNode); 
    sourceNode.playbackRate.value = parseFloat($('rate').value);
    if (isLooping) {
        sourceNode.loop = true; sourceNode.loopStart = loopStart; sourceNode.loopEnd = loopEnd;
    }
    sourceNode.start(0, startOffset);
    startTime = AC.currentTime - (startOffset / sourceNode.playbackRate.value);
    pausedAt = 0; isPlaying = true; playhead.style.display = 'block';
    $('play').classList.add('active');
    updateLoop();
    sourceNode.onended = () => { if (isPlaying && !isLooping) stop(); };
  }

  function pause() {
    if (!isPlaying || !sourceNode) return;
    pausedAt = (AC.currentTime - startTime) * sourceNode.playbackRate.value;
    sourceNode.stop();
    isPlaying = false; cancelAnimationFrame(animationFrameId);
    $('play').classList.remove('active');
  }

  function stop() {
    if (sourceNode) { try { sourceNode.stop(0); } catch(e) {} sourceNode = null; }
    isPlaying = false; pausedAt = isLooping ? loopStart : 0;
    startTime = 0; cancelAnimationFrame(animationFrameId);
    updateTimeDisplay(pausedAt); updatePlayhead();
    $('play').classList.remove('active');
  }

  $('play').onclick = () => { if (AC.state === 'suspended') { AC.resume().then(() => play(pausedAt)); } else { play(pausedAt); }};
  $('pause').onclick = pause;
  $('stop').onclick = stop;

  $('prevTrackBtn').onclick = () => {
      if (importedFiles.length < 2) return;
      const newIndex = (currentFileIndex - 1 + importedFiles.length) % importedFiles.length;
      loadFile(importedFiles[newIndex]);
  };
  $('nextTrackBtn').onclick = () => {
      if (importedFiles.length < 2) return;
      const newIndex = (currentFileIndex + 1) % importedFiles.length;
      loadFile(importedFiles[newIndex]);
  };

  function updateLoop() {
    if (!isPlaying || !sourceNode) return;
    let elapsed = (AC.currentTime - startTime) * sourceNode.playbackRate.value;
    if(isLooping && elapsed >= loopEnd){
        const loopDuration = loopEnd - loopStart;
        elapsed = loopStart + ((elapsed - loopStart) % loopDuration);
        startTime = AC.currentTime - (elapsed / sourceNode.playbackRate.value);
    }
    updateTimeDisplay(elapsed); updatePlayhead(elapsed);
    animationFrameId = requestAnimationFrame(updateLoop);
  }
  
  function formatTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return '00:00.0';
    const min = Math.floor(seconds / 60), sec = Math.floor(seconds % 60), ms = Math.floor((seconds - Math.floor(seconds)) * 10);
    return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}.${ms}`;
  }
  function updateTimeDisplay(currentTime = pausedAt) {
    const duration = audioBuffer ? audioBuffer.duration : 0;
    $('timeDisplay').textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
  }
  
  function resetUI() {
    clearSelection();
    updateTimeDisplay();
    updatePlayhead();
    zoom = 1;
    viewOffset = 0;
    const initialVolume = 0.2;
    $('gain').value = initialVolume;
    setVal('gainV', Number(initialVolume).toFixed(2));
    gain.gain.value = initialVolume;
  }
  
  const timeRuler = $('time-ruler'), timeHover = $('time-hover-info');
  timeRuler.onmousemove = e => {
    if(!audioBuffer) return;
    const rect = timeRuler.getBoundingClientRect();
    const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    const hoverTime = percent * audioBuffer.duration;
    timeHover.textContent = formatTime(hoverTime);
    timeHover.style.left = `${percent * 100}%`;
    timeHover.style.display = 'block';
  };
  timeRuler.onmouseleave = () => { timeHover.style.display = 'none'; };
  timeRuler.onclick = e => {
    if(!audioBuffer) return;
    const rect = timeRuler.getBoundingClientRect();
    const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
    const seekTime = percent * audioBuffer.duration;
    const wasPlaying = isPlaying;
    if (wasPlaying) pause();
    pausedAt = seekTime;
    updatePlayhead(); updateTimeDisplay();
    if(wasPlaying) play();
  };

  function updatePlayhead() {
      if (!audioBuffer) {
          playhead.style.display = 'none';
          return;
      }
      const currentTime = isPlaying ? ((AC.currentTime - startTime) * (sourceNode?.playbackRate.value || 1.0)) : pausedAt;
      const duration = audioBuffer.duration;
      const visibleStart = viewOffset;
      const visibleDuration = duration / zoom;
      const visibleEnd = visibleStart + visibleDuration;
      $('time-indicator').style.left = `${(currentTime/duration) * 100}%`;
      if (currentTime >= visibleStart && currentTime <= visibleEnd) {
          playhead.style.display = 'block';
          const percent = (currentTime - visibleStart) / visibleDuration;
          playhead.style.left = `${percent * 100}%`;
      } else {
          playhead.style.display = 'none';
      }
  }

  function drawWaveform() {
      const canvas = waveformCanvas;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.clientWidth * dpr;
      canvas.height = 100 * dpr;
      const ctx = waveformCtx;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!audioBuffer) return;
      ctx.scale(dpr, dpr);
      const data = audioBuffer.getChannelData(0);
      const totalSamples = data.length;
      const visibleSamples = Math.floor(totalSamples / zoom);
      const startSample = Math.floor(viewOffset * audioBuffer.sampleRate);
      const step = Math.ceil(visibleSamples / canvas.clientWidth);
      const amp = canvas.clientHeight / 2;
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(10, 132, 255, 0.6)';
      ctx.beginPath();
      for (let i = 0; i < canvas.clientWidth; i++) {
          const sampleIdx = startSample + (i * step);
          let min = 1.0; let max = -1.0;
          for (let j = 0; j < step; j++) {
              if (sampleIdx + j < totalSamples) {
                  const datum = data[sampleIdx + j];
                  if (datum < min) min = datum;
                  if (datum > max) max = datum;
              }
          }
          ctx.moveTo(i, (1 + min) * amp);
          ctx.lineTo(i, (1 + max) * amp);
      }
      ctx.stroke();
  }

  function pxToSeconds(px) {
    if (!audioBuffer) return 0;
    const visibleDuration = audioBuffer.duration / zoom;
    return viewOffset + (px / waveformCanvas.clientWidth) * visibleDuration;
  }

  waveformCanvas.onmousedown = e => {
    if (!audioBuffer) return;
    const rect = waveformCanvas.getBoundingClientRect(), startX = e.clientX - rect.left;
    if (e.shiftKey) { 
        isDragging = true; let lastX = e.clientX;
        const onMouseMove = moveE => {
            if (!isDragging) return;
            const dx = moveE.clientX - lastX; lastX = moveE.clientX;
            const deltaSeconds = (dx / waveformCanvas.clientWidth) * (audioBuffer.duration / zoom);
            viewOffset = Math.max(0, Math.min(viewOffset - deltaSeconds, audioBuffer.duration - audioBuffer.duration / zoom));
            drawWaveform(); updatePlayhead();
        };
        const onMouseUp = () => { isDragging = false; window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', onMouseUp); };
        window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp); return;
    }
    isDragging = true;
    selectionStart = pxToSeconds(startX);
    selectionEnd = selectionStart;
    selectionRect.style.left = `${startX}px`;
    selectionRect.style.width = '0px';
    selectionRect.style.display = 'block';
    const onMouseMove = moveE => {
        if (!isDragging) return;
        const currentX = Math.max(0, Math.min(moveE.clientX - rect.left, rect.width));
        const left = Math.min(startX, currentX), width = Math.abs(currentX - startX);
        selectionRect.style.left = `${left}px`;
        selectionRect.style.width = `${width}px`;
        selectionEnd = pxToSeconds(currentX);
    };
    const onMouseUp = () => {
        isDragging = false;
        if (selectionStart > selectionEnd) [selectionStart, selectionEnd] = [selectionEnd, selectionStart];
        $('loopStart').value = formatTime(selectionStart);
        $('loopEnd').value = formatTime(selectionEnd);
        loopStart = selectionStart; loopEnd = selectionEnd;
        window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', onMouseUp);
    };
    window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp);
  };
  
  function clearSelection(){
    selectionStart = 0; selectionEnd = 0;
    if(audioBuffer){
        $('loopStart').value = formatTime(0);
        $('loopEnd').value = formatTime(audioBuffer.duration);
    }
    selectionRect.style.display = 'none';
  }

  $('zoomInBtn').onclick = () => {
      if (!audioBuffer || zoom >= 256) return;
      const centerTime = viewOffset + (audioBuffer.duration / zoom) / 2;
      zoom *= 2;
      viewOffset = centerTime - (audioBuffer.duration / zoom) / 2;
      viewOffset = Math.max(0, Math.min(viewOffset, audioBuffer.duration - audioBuffer.duration / zoom));
      drawWaveform(); updatePlayhead();
  };
  $('zoomOutBtn').onclick = () => {
      if (!audioBuffer || zoom <= 1) return;
      const centerTime = viewOffset + (audioBuffer.duration / zoom) / 2;
      zoom /= 2;
      viewOffset = centerTime - (audioBuffer.duration / zoom) / 2;
      viewOffset = Math.max(0, Math.min(viewOffset, audioBuffer.duration - audioBuffer.duration / zoom));
      drawWaveform(); updatePlayhead();
  };
  $('zoomAllBtn').onclick = () => {
      if (!audioBuffer) return;
      zoom = 1; viewOffset = 0;
      drawWaveform(); updatePlayhead();
  };

  $('gain').oninput = e => { gain.gain.value = +e.target.value; setVal('gainV', Number(gain.gain.value).toFixed(2)); };
  $('pan').oninput = e => { pan.pan.value = +e.target.value; setVal('panV', Number(pan.pan.value).toFixed(2)); };
  $('rate').oninput = e => { const rateVal = +e.target.value; if(sourceNode) { sourceNode.playbackRate.value = rateVal; } setVal('rateV', `${Number(rateVal).toFixed(2)}x`); };
  $('hp').oninput = e=>{ hp.frequency.value = +e.target.value; setVal('hpV', `${Math.round(hp.frequency.value)} Hz`); };
  $('lp').oninput = e=>{ lp.frequency.value = +e.target.value; const d = lp.frequency.value >= 1000 ? (lp.frequency.value / 1000).toFixed(1) + ' kHz' : Math.round(lp.frequency.value) + ' Hz'; setVal('lpV', d); };
  $('peakF').oninput = e=>{ peak.frequency.value = +e.target.value; setVal('pfV', `${Math.round(peak.frequency.value)} Hz`); };
  $('peakG').oninput = e=>{ peak.gain.value = +e.target.value; setVal('pgV', `${Number(peak.gain.value).toFixed(1)} dB`); };
  $('peakQ').oninput = e=>{ peak.Q.value = +e.target.value; setVal('pqV', Number(peak.Q.value).toFixed(1)); };
  $('deqThreshold').oninput = e => {
      const val = +e.target.value;
      if (val > -100) {
          deqCompressor.threshold.value = val; deqCompressor.ratio.value = 4;
          deqMakeUp.gain.value = -val / 2;
          deqChainInput.connect(peak);
      } else {
          try { deqChainInput.disconnect(peak); } catch(e) {}
      }
      setVal('deqTV', val > -100 ? `${val} dB` : `-inf dB`);
  };

  $('compThreshold').oninput = e => setVal('compThresholdV', `${e.target.value} dB`);
  $('compRatio').oninput = e => setVal('compRatioV', `${Number(e.target.value).toFixed(1)}:1`);
  $('maximizeAmount').oninput = e => setVal('maximizeAmountV', `${e.target.value} %`);

  function updateBuffer(newBuffer) {
      const wasPlaying = isPlaying; stop(); audioBuffer = newBuffer;
      const duration = audioBuffer ? audioBuffer.duration : 0;
      $('loopStart').value = formatTime(0); $('loopEnd').value = formatTime(duration);
      loopStart = 0; loopEnd = duration;
      updateTimeDisplay(); clearSelection();
      drawWaveform();
      if(wasPlaying) play();
  }

  async function applyOfflineEffect(nodeSetupCallback) {
      if (!audioBuffer) { alert("è«‹å…ˆè¼‰å…¥éŸ³è¨Šæª”æ¡ˆ"); return; }
      const indicator = $('loadingIndicator');
      indicator.querySelector('div:last-child').textContent = 'éŸ³è¨Šè™•ç†ä¸­...';
      indicator.style.display = 'flex';
      await new Promise(resolve => setTimeout(resolve, 20)); 
      try {
          const offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
          const source = offlineCtx.createBufferSource();
          source.buffer = audioBuffer;
          const lastNode = nodeSetupCallback(offlineCtx, source);
          lastNode.connect(offlineCtx.destination);
          source.start(0);
          const renderedBuffer = await offlineCtx.startRendering();
          updateBuffer(renderedBuffer);
      } catch (e) {
          console.error("Error applying effect:", e);
          alert("å¥—ç”¨æ•ˆæœæ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚");
      } finally {
          indicator.style.display = 'none';
      }
  }

  $('normalizeBtn').onclick = () => {
    if (!audioBuffer) return; let peak = 0;
    for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
        const cd = audioBuffer.getChannelData(i);
        for (let j = 0; j < cd.length; j++) peak = Math.max(peak, Math.abs(cd[j]));
    }
    const gainVal = 0.89125 / (peak || 1);
    const newBuffer = AC.createBuffer(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
    for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
        const oldData = audioBuffer.getChannelData(i), newData = newBuffer.getChannelData(i);
        for (let j = 0; j < oldData.length; j++) newData[j] = oldData[j] * gainVal;
    }
    updateBuffer(newBuffer);
  };
  $('trimBtn').onclick = () => {
    if (!audioBuffer || selectionEnd === selectionStart) return;
    const start = Math.floor(selectionStart * audioBuffer.sampleRate), end = Math.floor(selectionEnd * audioBuffer.sampleRate), len = end - start;
    const newBuffer = AC.createBuffer(audioBuffer.numberOfChannels, len, audioBuffer.sampleRate);
    for (let i = 0; i < audioBuffer.numberOfChannels; i++) { newBuffer.getChannelData(i).set(audioBuffer.getChannelData(i).subarray(start, end)); }
    updateBuffer(newBuffer);
  };
  $('deleteBtn').onclick = () => {
    if (!audioBuffer || selectionEnd === selectionStart) return;
    const start = Math.floor(selectionStart * audioBuffer.sampleRate), end = Math.floor(selectionEnd * audioBuffer.sampleRate);
    const len = audioBuffer.length - (end - start);
    const newBuffer = AC.createBuffer(audioBuffer.numberOfChannels, len, audioBuffer.sampleRate);
    for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
      const oldData = audioBuffer.getChannelData(i), newData = newBuffer.getChannelData(i);
      newData.set(oldData.subarray(0, start)); newData.set(oldData.subarray(end), start);
    }
    updateBuffer(newBuffer);
  };

  $('applyCompressorBtn').onclick = () => {
      const threshold = parseFloat($('compThreshold').value);
      const ratio = parseFloat($('compRatio').value);
      applyOfflineEffect((ctx, sourceNode) => {
          const compressor = ctx.createDynamicsCompressor();
          compressor.threshold.setValueAtTime(threshold, ctx.currentTime);
          compressor.ratio.setValueAtTime(ratio, ctx.currentTime);
          compressor.knee.setValueAtTime(3, ctx.currentTime);
          compressor.attack.setValueAtTime(0.003, ctx.currentTime);
          compressor.release.setValueAtTime(0.25, ctx.currentTime);
          sourceNode.connect(compressor);
          return compressor;
      });
  };
  $('applyMaximizerBtn').onclick = () => {
      const amount = parseFloat($('maximizeAmount').value) / 100;
      const threshold = -30 * amount;
      const makeupGainValue = 1 + amount * 1.5;
      applyOfflineEffect((ctx, sourceNode) => {
          const limiter = ctx.createDynamicsCompressor();
          limiter.threshold.setValueAtTime(threshold, ctx.currentTime);
          limiter.ratio.setValueAtTime(20, ctx.currentTime);
          limiter.knee.setValueAtTime(0, ctx.currentTime);
          limiter.attack.setValueAtTime(0.001, ctx.currentTime);
          limiter.release.setValueAtTime(0.1, ctx.currentTime);
          const makeupGain = ctx.createGain();
          makeupGain.gain.setValueAtTime(makeupGainValue, ctx.currentTime);
          sourceNode.connect(limiter).connect(makeupGain);
          return makeupGain;
      });
  };

  const scopeCanvas = $('scope'), scopeCtx = scopeCanvas.getContext('2d');
  const oscilloscopeCanvas = $('oscilloscopeCanvas'), oscilloscopeCtx = oscilloscopeCanvas.getContext('2d');
  const vectorscopeCanvas = $('vectorscopeCanvas'), vectorscopeCtx = vectorscopeCanvas.getContext('2d');
  const peakMeterCanvas = $('peakMeterCanvas'), peakMeterCtx = peakMeterCanvas.getContext('2d');
  
  function getColorForValue(value) {
    const hue = (1 - value) * 240;
    return `hsl(${hue}, 100%, 50%)`;
  }

  function drawAnalyzers(){
    requestAnimationFrame(drawAnalyzers);
    const dpr = window.devicePixelRatio || 1;
    
    [scopeCanvas, oscilloscopeCanvas, vectorscopeCanvas, peakMeterCanvas].forEach(canvas => {
        if (canvas.width !== canvas.clientWidth * dpr || canvas.height !== canvas.clientHeight * dpr) {
            canvas.width = canvas.clientWidth * dpr;
            canvas.height = canvas.clientHeight * dpr;
        }
    });
    
    const bufferLength = analyser.frequencyBinCount;
    const freqData = new Uint8Array(bufferLength);
    const timeData = new Uint8Array(bufferLength);
    const timeDataL = new Uint8Array(analyserL.fftSize);
    const timeDataR = new Uint8Array(analyserR.fftSize);

    analyser.getByteFrequencyData(freqData);
    analyser.getByteTimeDomainData(timeData);
    analyserL.getByteTimeDomainData(timeDataL);
    analyserR.getByteTimeDomainData(timeDataR);

    scopeCtx.clearRect(0, 0, scopeCanvas.width, scopeCanvas.height);
    const bars = freqData.length;
    const bw = scopeCanvas.width / bars;
    for(let i = 0; i < bars; i++){
        const v = freqData[i] / 255;
        const h = v * scopeCanvas.height;
        scopeCtx.fillStyle = getColorForValue(v);
        scopeCtx.fillRect(i * bw, scopeCanvas.height - h, bw * 0.9, h);
    }

    oscilloscopeCtx.clearRect(0, 0, oscilloscopeCanvas.width, oscilloscopeCanvas.height);
    oscilloscopeCtx.lineWidth = 2 * dpr;
    oscilloscopeCtx.strokeStyle = 'rgb(10, 132, 255)';
    oscilloscopeCtx.beginPath();
    const sliceWidth = oscilloscopeCanvas.width * 1.0 / bufferLength;
    let x = 0;
    for(let i = 0; i < bufferLength; i++) {
        const v = timeData[i] / 128.0;
        const y = v * oscilloscopeCanvas.height / 2;
        if(i === 0) oscilloscopeCtx.moveTo(x, y);
        else oscilloscopeCtx.lineTo(x, y);
        x += sliceWidth;
    }
    oscilloscopeCtx.lineTo(oscilloscopeCanvas.width, oscilloscopeCanvas.height / 2);
    oscilloscopeCtx.stroke();

    vectorscopeCtx.fillStyle = 'rgba(0,0,0,0.1)';
    vectorscopeCtx.fillRect(0, 0, vectorscopeCanvas.width, vectorscopeCanvas.height);
    vectorscopeCtx.fillStyle = '#00CA4E';
    for (let i = 0; i < timeDataL.length; i++) {
        const x = (timeDataL[i] / 255) * vectorscopeCanvas.width;
        const y = (1 - timeDataR[i] / 255) * vectorscopeCanvas.height;
        vectorscopeCtx.fillRect(x, y, dpr, dpr);
    }
    
    peakMeterCtx.clearRect(0, 0, peakMeterCanvas.width, peakMeterCanvas.height);
    const meterWidth = peakMeterCanvas.width / 2 - 10 * dpr;
    const meterGradient = peakMeterCtx.createLinearGradient(0, peakMeterCanvas.height, 0, 0);
    meterGradient.addColorStop(0, '#00CA4E');
    meterGradient.addColorStop(0.7, '#FFBD44');
    meterGradient.addColorStop(0.9, '#FF605C');
    
    let peakL = 0, peakR = 0;
    for(let i = 0; i < timeDataL.length; i++) {
        peakL = Math.max(peakL, Math.abs(timeDataL[i] - 128));
        peakR = Math.max(peakR, Math.abs(timeDataR[i] - 128));
    }
    const levelL = (peakL / 128) * peakMeterCanvas.height;
    const levelR = (peakR / 128) * peakMeterCanvas.height;
    
    peakMeterCtx.fillStyle = meterGradient;
    peakMeterCtx.fillRect(5 * dpr, peakMeterCanvas.height - levelL, meterWidth, levelL);
    peakMeterCtx.fillRect(meterWidth + 15 * dpr, peakMeterCanvas.height - levelR, meterWidth, levelR);
  } 
  drawAnalyzers();
  
  function parseTimeToSeconds(timeStr) {
    const parts = String(timeStr).split(/[:.]/);
    if(parts.length < 2) return 0;
    return (parseInt(parts[0] || 0, 10) * 60) + parseInt(parts[1] || 0, 10) + (parseFloat(parts[2] || 0) / 10);
  }
  $('loopStart').onchange = () => { 
    loopStart = parseTimeToSeconds($('loopStart').value);
    if (!isPlaying) {
        pausedAt = loopStart;
        updatePlayhead();
        updateTimeDisplay();
    }
  };
  $('loopEnd').onchange = () => { loopEnd = parseTimeToSeconds($('loopEnd').value) || (audioBuffer ? audioBuffer.duration : 0); };
  $('loopToggle').onchange = e => {
      isLooping = e.target.checked;
      if (isPlaying) {
          const currentPlayTime = (AC.currentTime - startTime) * sourceNode.playbackRate.value;
          pause(); play(currentPlayTime);
      }
  };

  let selectedExportFormat = 'wav', selectedChannelMode = 'source';
  const formatButtons = document.querySelectorAll('#formatSelector .format-btn');
  formatButtons.forEach(b => b.onclick = () => { formatButtons.forEach(btn => btn.classList.remove('active')); b.classList.add('active'); selectedExportFormat = b.dataset.format; $('mp3Options').style.display = selectedExportFormat === 'mp3' ? 'flex' : 'none'; });
  const channelButtons = document.querySelectorAll('#channelSelector .format-btn');
  channelButtons.forEach(b => b.onclick = () => { channelButtons.forEach(btn => btn.classList.remove('active')); b.classList.add('active'); selectedChannelMode = b.dataset.channels; });
  $('mp3Bitrate').oninput = e => setVal('mp3BitrateV', `${e.target.value} kbps`);
  $('export').onclick = () => { if(!audioBuffer) { alert("è«‹å…ˆè¼‰å…¥éŸ³è¨Šæª”æ¡ˆ"); return; } $('mainRightPanel').style.display = 'none'; $('exportPanel').style.display = 'flex'; };
  $('cancelExportBtn').onclick = () => { $('exportPanel').style.display = 'none'; $('mainRightPanel').style.display = 'block'; };
  $('exportGain').oninput = e => setVal('exportGainV', Number(e.target.value).toFixed(2));
  
  function bufferToWav(buffer) {
    const numOfChan = buffer.numberOfChannels, length = buffer.length * numOfChan * 2 + 44, ab = new ArrayBuffer(length), view = new DataView(ab);
    let offset = 0; const writeStr = (s) => { for (let i = 0; i < s.length; i++) view.setUint8(offset++, s.charCodeAt(i)); };
    writeStr('RIFF'); view.setUint32(offset, 36 + buffer.length * numOfChan * 2, true); offset += 4;
    writeStr('WAVE'); writeStr('fmt '); view.setUint32(offset, 16, true); offset += 4; view.setUint16(offset, 1, true); offset += 2; view.setUint16(offset, numOfChan, true); offset += 2;
    view.setUint32(offset, buffer.sampleRate, true); offset += 4; view.setUint32(offset, buffer.sampleRate * numOfChan * 2, true); offset += 4;
    view.setUint16(offset, numOfChan * 2, true); offset += 2; view.setUint16(offset, 16, true); offset += 2;
    writeStr('data'); view.setUint32(offset, buffer.length * numOfChan * 2, true); offset += 4;
    for (let ch = 0; ch < numOfChan; ch++) {
        const chanData = buffer.getChannelData(ch);
        for (let i = 0; i < buffer.length; i++) {
            let s = Math.max(-1, Math.min(1, chanData[i]));
            view.setInt16(offset + (i * numOfChan + ch) * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
    }
    return new Blob([view], { type: 'audio/wav' });
  }

  function bufferToMp3(buffer, bitrate) {
    return new Promise((resolve, reject) => {
        if (!mp3EncoderWorker) {
            const encoderJsString = `
                self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.0/lame.min.js');
                self.onmessage = function (e) {
                    if (e.data.command === 'encode') {
                        const mp3Data = encode(e.data);
                        self.postMessage({ command: 'end', buffer: mp3Data });
                    }
                };
                function encode({ channelData, sampleRate, bitrate, channels }) {
                    const mp3Encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
                    const sampleBlockSize = 1152;
                    const mp3Data = [];
                    const convertToInt16 = (floatArray) => {
                        const intArray = new Int16Array(floatArray.length);
                        for (let i = 0; i < floatArray.length; i++) {
                            const sample = Math.max(-1, Math.min(1, floatArray[i]));
                            intArray[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        }
                        return intArray;
                    };
                    let pcm_i16_channels = [];
                    if (channels === 1) {
                        const mono_f32 = new Float32Array(channelData[0].length);
                        if (channelData.length > 1) {
                            const left = channelData[0];
                            const right = channelData[1];
                            for(let i = 0; i < channelData[0].length; i++) {
                                mono_f32[i] = (left[i] + right[i]) * 0.5;
                            }
                        } else {
                            mono_f32.set(channelData[0]);
                        }
                        pcm_i16_channels.push(convertToInt16(mono_f32));
                    } else {
                        const left_f32 = channelData[0];
                        const right_f32 = channelData.length > 1 ? channelData[1] : left_f32;
                        pcm_i16_channels.push(convertToInt16(left_f32));
                        pcm_i16_channels.push(convertToInt16(right_f32));
                    }
                    const dataLength = pcm_i16_channels[0].length;
                    for (let i = 0; i < dataLength; i += sampleBlockSize) {
                        const sampleChunks = pcm_i16_channels.map(channelData => channelData.subarray(i, i + sampleBlockSize));
                        const mp3buf = mp3Encoder.encodeBuffer(...sampleChunks);
                        if (mp3buf.length > 0) {
                            mp3Data.push(mp3buf);
                        }
                    }
                    const flushed = mp3Encoder.flush();
                    if (flushed.length > 0) {
                        mp3Data.push(flushed);
                    }
                    return mp3Data;
                }
            `;
            const blob = new Blob([encoderJsString], { type: 'application/javascript' });
            mp3EncoderWorker = new Worker(URL.createObjectURL(blob));
        }

        const channelData = [];
        for (let i = 0; i < buffer.numberOfChannels; i++) {
            channelData.push(buffer.getChannelData(i));
        }

        mp3EncoderWorker.onmessage = (e) => {
            if (e.data.command === 'end') {
                resolve(new Blob(e.data.buffer, { type: 'audio/mp3' }));
            }
        };
        
        mp3EncoderWorker.onerror = (e) => {
            reject(new Error(`Worker error: ${e.message}`));
        };

        mp3EncoderWorker.postMessage({
            command: 'encode',
            channelData: channelData,
            sampleRate: buffer.sampleRate,
            bitrate: bitrate,
            channels: (selectedChannelMode === 'mono') ? 1 : buffer.numberOfChannels
        });
    });
  }

  $('saveFileBtn').onclick = async () => {
    if (!audioBuffer) return;
    const status = $('exportStatus'), saveBtn = $('saveFileBtn');
    const statusText = $('exportStatusText');
    const spinner = status.querySelector('.spinner');

    status.style.display = 'flex'; 
    spinner.style.display = 'block';
    statusText.textContent = 'éŸ³è¨Šè™•ç†ä¸­ï¼Œè«‹ç¨å€™...';
    status.style.color = 'var(--blue)';
    saveBtn.disabled = true;
    
    let exportError = null;
    try {
        await new Promise(resolve => setTimeout(resolve, 50));
        
        const originalFileName = importedFiles[currentFileIndex]?.name.replace(/\.[^/.]+$/, "") || "audio_file";
        const splitCount = parseInt($('splitCount').value) || 1;
        if (splitCount < 1) throw new Error("åˆ†å‰²ä»½æ•¸ç„¡æ•ˆ");

        for (let i = 0; i < splitCount; i++) {
            statusText.textContent = `è™•ç†ä¸­... (${i + 1}/${splitCount})`;
            const partLength = Math.floor(audioBuffer.length / splitCount);
            const startOffset = i * partLength;
            const endOffset = (i + 1) === splitCount ? audioBuffer.length : (i + 1) * partLength;
            const bufferToRender = AC.createBuffer(audioBuffer.numberOfChannels, endOffset - startOffset, audioBuffer.sampleRate);
            for(let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
                bufferToRender.copyToChannel(audioBuffer.getChannelData(ch).subarray(startOffset, endOffset), ch);
            }
            
            const offlineCtx = new OfflineAudioContext(bufferToRender.numberOfChannels, bufferToRender.length, bufferToRender.sampleRate);
            const oSrc = offlineCtx.createBufferSource(); oSrc.buffer = bufferToRender;
            const oHp = offlineCtx.createBiquadFilter(), oPeak = offlineCtx.createBiquadFilter(), oLp = offlineCtx.createBiquadFilter();
            const oPan = offlineCtx.createStereoPanner(), oGain = offlineCtx.createGain(), oExportGain = offlineCtx.createGain();
            const oDeqC = offlineCtx.createDynamicsCompressor(), oDeqI = offlineCtx.createGain(), oDeqM = offlineCtx.createGain();
            
            oHp.type = 'highpass'; oHp.frequency.value = hp.frequency.value; oHp.Q.value = 0.707;
            oLp.type = 'lowpass'; oLp.frequency.value = lp.frequency.value; oLp.Q.value = 0.707;
            oPeak.type = 'peaking'; oPeak.frequency.value = peak.frequency.value; oPeak.gain.value = peak.gain.value; oPeak.Q.value = peak.Q.value;
            oPan.pan.value = pan.pan.value;
            oGain.gain.value = gain.gain.value;
            oExportGain.gain.value = parseFloat($('exportGain').value);
            oSrc.playbackRate.value = parseFloat($('rate').value);

            let lastNode = oSrc.connect(oHp).connect(oLp).connect(oPan);
            
            const deqThresh = parseFloat($('deqThreshold').value);
            if (deqThresh > -100) {
                oDeqC.threshold.value = deqThresh; oDeqC.ratio.value = 4; oDeqC.attack.value = 0.001; oDeqC.release.value = 0.1;
                oDeqI.gain.value = -1; oDeqM.gain.value = -deqThresh / 2;
                lastNode.connect(oPeak).connect(oDeqC).connect(oDeqI).connect(oDeqM);
                oDeqM.connect(oGain);
                lastNode.connect(oGain);
                lastNode = oGain;
            } else {
                lastNode.connect(oGain);
                lastNode = oGain;
            }
            
            lastNode.connect(oExportGain).connect(offlineCtx.destination);
            oSrc.start(0);

            const renderedBuffer = await offlineCtx.startRendering();
            let audioBlob, fileExtension;
            if (selectedExportFormat === 'wav') { 
                audioBlob = bufferToWav(renderedBuffer); 
                fileExtension = 'wav'; 
            } 
            else { 
                audioBlob = await bufferToMp3(renderedBuffer, parseInt($('mp3Bitrate').value)); 
                fileExtension = 'mp3'; 
            }
            const url = URL.createObjectURL(audioBlob), a = $('download');
            a.href = url;
            const fileName = splitCount > 1 ? `${originalFileName}_part${i+1}.${fileExtension}` : `${originalFileName}_processed.${fileExtension}`;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url);
            
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        statusText.textContent = `åŒ¯å‡ºå®Œæˆ (${splitCount}å€‹æª”æ¡ˆ)!`;
        spinner.style.display = 'none';
    } catch(e) { 
        console.error("Export failed:", e); 
        statusText.textContent = 'åŒ¯å‡ºå¤±æ•—';
        status.style.color = 'var(--red)';
        spinner.style.display = 'none';
        exportError = e;
    } finally {
        saveBtn.disabled = false;
        if (!exportError) {
            setTimeout(() => {
                status.style.display = 'none';
                $('cancelExportBtn').click();
            }, 2500);
        }
    }
  };
  
  // ===== Theme Toggler Logic =====
  const themeToggle = $('theme-toggle');
  const htmlEl = document.documentElement;
  
  function setDarkTheme(isDark) {
    if (isDark) {
      htmlEl.classList.add('dark-theme');
      localStorage.setItem('theme', 'dark');
    } else {
      htmlEl.classList.remove('dark-theme');
      localStorage.setItem('theme', 'light');
    }
  }

  themeToggle.addEventListener('click', () => {
    setDarkTheme(!htmlEl.classList.contains('dark-theme'));
  });

  document.addEventListener('DOMContentLoaded', () => {
    updateFileList();
    const savedTheme = localStorage.getItem('theme') || 'light';
    setDarkTheme(savedTheme === 'dark');
  });

  </script>
</body>
</html>
